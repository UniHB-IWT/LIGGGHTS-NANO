//#**************************************************************
//#
//# filename:             mbssolset_convert_auto.h 
//#
//# author:               Gerstmayr, Reischl, Saxinger
//#
//# generated:	
//# description: 
//# remarks:		
//#
//# Copyright (c) 2003-2013 Johannes Gerstmayr, Linz Center of Mechatronics GmbH, Austrian
//# Center of Competence in Mechatronics GmbH, Institute of Technical Mechanics at the 
//# Johannes Kepler Universitaet Linz, Austria. All rights reserved.
//#
//# This file is part of HotInt.
//# HotInt is free software: you can redistribute it and/or modify it under the terms of 
//# the HOTINT license. See folder "licenses" for more details.
//#
//# bug reports are welcome!!!
//# WWW:		www.hotint.org
//# email:	bug_reports@hotint.org or support@hotint.org
//#***************************************************************************************

//File automatically generated by Octave/Matlab script "documentation/autogeneration/generate_mbssolset_fn"!
//Do not manually change this file, because it will be overwritten
//Changes of the SolverSettings structure and initial values can be made in the tabular file "documentation/autogeneration/mbssolset_auto.txt"!
void MultiBodySystem::SolverOptions2EDC(ElementDataContainer* edc)
{
  ElementData ed;
  ed.SetDouble(GetSolSet().starttime, "start_time"); ed.SetToolTipText("Starting time of simulation, usually 0; for static and timeint solver"); edc->TreeAdd("SolverOptions",ed);
  ed.SetDouble(GetSolSet().endtime, "end_time"); ed.SetToolTipText("Final simulation time; for static and timeint solver"); edc->TreeAdd("SolverOptions",ed);
  ed.SetBool(GetSolSet().dostaticcomputation, "do_static_computation"); ed.SetToolTipText("Do only static computation; velocities and acceleration terms are ignored; system may not have kinematic degrees of freedom."); edc->TreeAdd("SolverOptions",ed);
  ed.SetDouble(GetSolSet().maxstepsize, "max_step_size"); ed.SetToolTipText("Maxial step size of timeint solver."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetDouble(GetSolSet().minstepsize, "min_step_size"); ed.SetToolTipText("Minimal step size of timeint solver."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetInt(GetSolSet().maxindex, "max_index"); ed.SetToolTipText("maximum index which solver the solver needs to handle"); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetText(GetSolSet().tableauname, "tableau_name"); ed.SetToolTipText("Runge Kutta tableau chosen"); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetInt(GetSolSet().maxstages, "max_stages"); ed.SetToolTipText("Number of stages for simulation, max. stages for variable order."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetInt(GetSolSet().minstages, "min_stages"); ed.SetToolTipText("Min. stages for variable order."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetBool(GetSolSet().fulladaptive, "automatic_stepsize_control"); ed.SetToolTipText("1|(0) ... Full adaptive stepsize selection of timeint is (not) active?"); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetDouble(GetSolSet().initstepsize, "init_step_size"); ed.SetToolTipText("Initial stepsize for timeint."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetDouble(GetSolSet().absaccuracy, "absolute_accuracy"); ed.SetToolTipText("Absolute accuracy, for full adaptive timeint."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetDouble(GetSolSet().relaccuracy, "relative_accuracy"); ed.SetToolTipText("Relative accuracy, for full adaptive timeint."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetInt(GetSolSet().variable_order, "variable_order"); ed.SetToolTipText("1|(0) ... Variable order algorithm  is (not) active."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetBool(GetSolSet().doimplicitintegration, "do_implicit_integration"); ed.SetToolTipText("1 .. Use implicit integration, 0..use explicit integration."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetBool(GetSolSet().reset_after_simulation, "reset_after_simulation"); ed.SetToolTipText("Reset start time and initial values after each simulation."); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetBool(GetSolSet().assume_constant_mass_matrix, "assume_constant_mass_matrix"); ed.SetToolTipText("Experimental version of constant mass matrix (WARNING: experimental only)"); edc->TreeAdd("SolverOptions.Timeint",ed);
  ed.SetDouble(GetSolSet().static_minloadinc, "min_load_inc"); ed.SetToolTipText("Minimal increment."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().static_maxloadinc, "max_load_inc"); ed.SetToolTipText("Maximum load increment."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().static_initloadinc, "init_load_inc"); ed.SetToolTipText("Initial load increment."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().static_loadinc_up, "load_inc_up"); ed.SetToolTipText("Increase load increment if success very often."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().static_loadinc_down, "load_inc_down"); ed.SetToolTipText("Decrease load increment if no success."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetInt(GetSolSet().static_incloadinc, "increase_load_inc_steps"); ed.SetToolTipText("If increase_load_inc_steps successfull steps --> leads to increase of load increment."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().static_spring_type_reg_param, "spring_regularisation_parameter"); ed.SetToolTipText("Spring-type regularisation parameter to stabilize almost kinematic systems during static comp."); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetInt(GetSolSet().static_use_tol_relax_factor, "use_tolerance_relax_factor"); ed.SetToolTipText("Enables/disables [1/0] the use of the relaxation factor on the tolerance goal (discontinuous accuracy) within static comp. Relaxation depends on load factor (0..1)"); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().static_maxtol_relax_factor, "max_tolerance_relax_factor"); ed.SetToolTipText("Uper bound for relaxation factor on the tolerance goal (discontinuous accuracy)"); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetBool(GetSolSet().static_experimental_sparse_jacobian, "experimental_sparse_jacobian"); ed.SetToolTipText("Experimental: optimized (low memory) sparse jacobian matrix"); edc->TreeAdd("SolverOptions.Static",ed);
  ed.SetDouble(GetSolSet().nls_relativeaccuracy, "relative_accuracy"); ed.SetToolTipText("Relative accuracy for Newton method"); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetDouble(GetSolSet().nls_absoluteaccuracy, "absolute_accuracy"); ed.SetToolTipText("Absolute accuracy for Newton method"); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetDouble(GetSolSet().nls_numdiffepsi, "num_diff_parameter"); ed.SetToolTipText("Numerical differentiation parameter"); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetBool(GetSolSet().nls_symmetricjacobian, "use_central_diff_quotient"); ed.SetToolTipText("Use central difference quotient for numerical differentiation ( slower )."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetBool(GetSolSet().nls_modifiednewton, "use_modified_newton"); ed.SetToolTipText("Use modified Newton ( approximated Jacobian, much faster )."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetInt(GetSolSet().nls_maxmodnewtonsteps, "max_modified_newton_steps"); ed.SetToolTipText("Max. modified Newton steps."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetInt(GetSolSet().nls_maxrestartnewtonsteps, "max_restart_newton_steps"); ed.SetToolTipText("Max. modified Newton steps after restart."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetInt(GetSolSet().nls_maxfullnewtonsteps, "max_full_newton_steps"); ed.SetToolTipText("Max. full Newton steps."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetBool(GetSolSet().nls_trustregion, "use_trust_region"); ed.SetToolTipText("0...do not use trust region; 1..use line search algorithm for newton's method, usually not necessary."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetDouble(GetSolSet().nls_trustregiondiv, "trust_region_division"); ed.SetToolTipText("Increment for line search."); edc->TreeAdd("SolverOptions.Newton",ed);
  ed.SetBool(GetSolSet().do_eigenmode_comp, "do_eigenmode_computation"); ed.SetToolTipText("This overwrites the dostaticcomputation flag and activates eigenmode computation on button START."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetBool(GetSolSet().eigsolv_reuse_last_eigvec, "reuse_last_eigenvectors"); ed.SetToolTipText("Reuse eigenvectors from last computation (faster, but might be eigenvectors from different system)."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetInt(GetSolSet().eigsolv_n_eigvals, "n_eigvals"); ed.SetToolTipText("Number of eigenvalues and eigenmodes to be computed for sparse iterative methods."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetInt(GetSolSet().eigsolv_maxiterations, "max_iterations"); ed.SetToolTipText("Maximum number of iterations for iterative eigenvalue solver."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetInt(GetSolSet().eigsolv_solvertype, "solver_type"); ed.SetToolTipText("Solvertype for eigenvalue computations: 0..direct (LAPACK), 1..Arnoldi (Matlab), 2..LOBPCG (HotInt)."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetInt(GetSolSet().eigsolv_nzeromodes, "n_zero_modes"); ed.SetToolTipText("Number of zero eigenvalues (convergence check)."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetBool(GetSolSet().eigsolv_use_nzeromodes, "use_n_zero_modes"); ed.SetToolTipText("Check convergence for zero eigenvalues."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetBool(GetSolSet().eigsolv_use_preconditioning, "use_preconditioning"); ed.SetToolTipText("Use preconditioner inv(K + lambda M)"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetDouble(GetSolSet().eigsolv_accuracy, "accuracy"); ed.SetToolTipText("Tolerance for iterative Eigenvalue solver."); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetDouble(GetSolSet().eigsolv_precond_lambda, "preconditioner_lambda"); ed.SetToolTipText("lambda for preconditioner inv(K + lambda M)"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetDouble(GetSolSet().eigsolv_eigenmodes_scaling_factor, "eigenmodes_scaling_factor"); ed.SetToolTipText("scaling factor for the eigenmodes"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetInt(GetSolSet().eigsolv_normalization_mode, "eigenmodes_normalization_mode"); ed.SetToolTipText("0 (standard)... max(v) = 1 , 1.. v'v = 1"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetBool(GetSolSet().eigsolv_linearize_about_act_sol, "linearize_about_actual_solution"); ed.SetToolTipText("Use actual solution as configuration for linearization of K/M"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetBool(GetSolSet().eigsolv_gyro, "use_gyroscopic_terms"); ed.SetToolTipText("Use gyroscopy terms for Eigenvalue computation"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetInt(GetSolSet().eigval_outp_format_flag, "eigval_outp_format_flag"); ed.SetToolTipText("print (bitwise sum) 1 .. eigenfreq., 2 .. eigenvec., 4 .. eigenfreq. in Hz (otherwise in rad/s)"); edc->TreeAdd("SolverOptions.Eigensolver",ed);
  ed.SetBool(GetSolSet().nls_usesparsesolver, "use_sparse_solver"); ed.SetToolTipText("1|(0) ... Sparse Jacobian and sparse solver is (not)activated."); edc->TreeAdd("SolverOptions.Linalg",ed);
  ed.SetBool(GetSolSet().nls_solve_undetermined_system, "undetermined_system"); ed.SetToolTipText("1|(0) ... Solve system which is overdetermined (least squares solution) or underdetermined (minimum norm solution) via LAPACK routine dgels."); edc->TreeAdd("SolverOptions.Linalg",ed);
  ed.SetDouble(GetSolSet().nls_estimated_condition_number, "estimated_condition_number"); ed.SetToolTipText("Used for considering equations to be linearly dependent when solving undetermined systems. Use together with option undetermined_system."); edc->TreeAdd("SolverOptions.Linalg",ed);
  ed.SetDouble(GetSolSet().discontinuousaccuracy, "absolute_accuracy"); ed.SetToolTipText("Accuracy for discontinuous problems ( plasticity, contact, friction, ... )."); edc->TreeAdd("SolverOptions.Discontinuous",ed);
  ed.SetInt(GetSolSet().maxdiscontinuousit, "max_iterations"); ed.SetToolTipText("Max. number of iterations for discont. problems."); edc->TreeAdd("SolverOptions.Discontinuous",ed);
  ed.SetBool(GetSolSet().ignore_maxdiscontinuousit, "ignore_max_iterations"); ed.SetToolTipText("continue anyway if error goal is not reached after max discontinuous iterations"); edc->TreeAdd("SolverOptions.Discontinuous",ed);
  ed.SetBool(GetSolSet().writeresults, "write_solution"); ed.SetToolTipText("(0)|1 ... (Don't) write results to file."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetInt(GetSolSet().writesolstep, "write_solution_every_x_step"); ed.SetToolTipText("Write solution every xx steps."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetDouble(GetSolSet().storedata, "store_data_every"); ed.SetToolTipText("Store data with data-manager, redraw and create animations: # -2 == always, -1 == at max stepsize, 0 = never, x.x = at every time x.x."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetBool(GetSolSet().sol_data_to_files, "store_data_to_files"); ed.SetToolTipText("if checked, then solution data (for data manager) is stored in files, instead of memory; these files are located in subdirectory solution_data of 'GeneralOptions.Paths.sensor_output_path'."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetBool(GetSolSet().sol_immediately_write, "immediately_write_file"); ed.SetToolTipText("1 ... SLOW: immediately write data to file with '<< flush' (no buffering), 0=FAST"); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetBool(GetSolSet().sol_replace_files, "always_replace_files"); ed.SetToolTipText("1 = always replace files, 0 = append solution to files"); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetBool(GetSolSet().sol_write_sol_file_header, "write_solution_file_header"); ed.SetToolTipText("Write solution file header."); edc->TreeAdd("SolverOptions.Solution.SolutionFile",ed);
  ed.SetText(GetSolSet().sol_file_header_comment, "solution_file_header_comment"); ed.SetToolTipText("Comment written in solution file header."); edc->TreeAdd("SolverOptions.Solution.SolutionFile",ed);
  ed.SetText(GetSolSet().sol_directory, "sensor_output_path"); ed.SetToolTipText("Relative or absolute path to output directory."); edc->TreeAdd("GeneralOptions.Paths",ed);
  ed.SetText(GetSolSet().sol_filename, "output_filename"); ed.SetToolTipText("Filename for general solution file (sensor output)."); edc->TreeAdd("SolverOptions.Solution.SolutionFile",ed);
  ed.SetText(GetSolSet().sol_parfilename, "parameter_variation_filename"); ed.SetToolTipText("Filename for parameter variation solution file."); edc->TreeAdd("SolverOptions.Solution.ParameterFile",ed);
  ed.SetBool(GetSolSet().sol_parfile_write_final_sensor_values, "write_final_sensor_values"); ed.SetToolTipText("Write final sensor values into parameter file."); edc->TreeAdd("SolverOptions.Solution.ParameterFile",ed);
  ed.SetBool(GetSolSet().sol_parfile_write_cost_function, "write_cost_function"); ed.SetToolTipText("Write cost function of sensors into parameter file."); edc->TreeAdd("SolverOptions.Solution.ParameterFile",ed);
  ed.SetBool(GetSolSet().sol_parfile_write_second_order_size, "write_second_order_size"); ed.SetToolTipText("Write second order size into parameter file."); edc->TreeAdd("SolverOptions.Solution.ParameterFile",ed);
  ed.SetBool(GetSolSet().sol_parfile_write_CPU_time, "write_CPU_time"); ed.SetToolTipText("Write CPU-time into parameter file."); edc->TreeAdd("SolverOptions.Solution.ParameterFile",ed);
  ed.SetInt(GetSolSet().storesolution_state, "store_solution_state"); ed.SetToolTipText("Store final solution state in file."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetText(GetSolSet().storesolution_statename, "store_solution_state_name"); ed.SetToolTipText("Filename for final solution state storage."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetInt(GetSolSet().loadsolution_state, "load_solution_state"); ed.SetToolTipText("Load initial configuration from file."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetText(GetSolSet().loadsolution_statename, "load_solution_state_name"); ed.SetToolTipText("Filename for initial configuration."); edc->TreeAdd("SolverOptions.Solution",ed);
  ed.SetBool(GetSolSet().postproc_compute_eigenvalues, "postproc_compute_eigenvalues"); ed.SetToolTipText("Compute eigenvalues in postprocessing."); edc->TreeAdd("SolverOptions.Solution.Sensor",ed);
  ed.SetBool(GetSolSet().store_FE_matrices, "store_finite_elements_matrices"); ed.SetToolTipText("Store intermediate matrices for finite elements (faster, but uses huge memory)."); edc->TreeAdd("SolverOptions.Element",ed);
  ed.SetBool(GetSolSet().element_wise_jacobian, "element_wise_jacobian"); ed.SetToolTipText("Jacobian is computed only for each element, taking into account known couplings."); edc->TreeAdd("SolverOptions.Element",ed);
  ed.SetBool(GetSolSet().parvar_activate, "activate"); ed.SetToolTipText("Do multiple computations by varying a parameter in a certain range."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetBool(GetSolSet().parvar_geometric, "geometric"); ed.SetToolTipText("Vary parameter geometrically (a*x, a*a*x, a*a*a*x, ...)."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetDouble(GetSolSet().parvar_start_value, "start_value"); ed.SetToolTipText("Start value for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetDouble(GetSolSet().parvar_end_value, "end_value"); ed.SetToolTipText("Final value for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetDouble(GetSolSet().parvar_step_lin, "arithmetic_step"); ed.SetToolTipText("Arithmetic step size for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetDouble(GetSolSet().parvar_step_geom, "geometric_step"); ed.SetToolTipText("Geometric factor for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetText(GetSolSet().parvar_EDCvarname, "MBS_EDC_variable_name"); ed.SetToolTipText("Path and variablename in MBS EDC which shall be varied in parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation",ed);
  ed.SetBool(GetSolSet().parvar2_activate, "activate"); ed.SetToolTipText("Do multiple computations by varying a parameter in a certain range."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetBool(GetSolSet().parvar2_geometric, "geometric"); ed.SetToolTipText("Vary parameter geometrically (a*x, a*a*x, a*a*a*x, ...)."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetDouble(GetSolSet().parvar2_start_value, "start_value"); ed.SetToolTipText("Start value for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetDouble(GetSolSet().parvar2_end_value, "end_value"); ed.SetToolTipText("Final value for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetDouble(GetSolSet().parvar2_step_lin, "arithmetic_step"); ed.SetToolTipText("Arithmetic step size for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetDouble(GetSolSet().parvar2_step_geom, "geometric_step"); ed.SetToolTipText("Geometric factor for parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetText(GetSolSet().parvar2_EDCvarname, "MBS_EDC_variable_name"); ed.SetToolTipText("Path and variablename in MBS EDC which shall be varied in parameter variation."); edc->TreeAdd("SolverOptions.ParameterVariation.Var2",ed);
  ed.SetBool(GetSolSet().paropt_activate, "activate"); ed.SetToolTipText("Do multiple computations by genetic optimization of parameter(s) in a certain range."); edc->TreeAdd("SolverOptions.Optimization",ed);
  ed.SetBool(GetSolSet().paropt_run_with_nominal_parameters, "run_with_nominal_parameters"); ed.SetToolTipText("(0)1 ... (Don't) perform single simulation with nominal parameters."); edc->TreeAdd("SolverOptions.Optimization",ed);
  ed.SetInt(GetSolSet().paropt_sensors, "sensors"); ed.SetToolTipText("Define sensor number(s) here; (the sum of) the end value(s) of the sensor signal time history is defined as cost function. The use of more than one sensor is planned."); edc->TreeAdd("SolverOptions.Optimization",ed);
  ed.SetBool(GetSolSet().paropt_restart, "restart"); ed.SetToolTipText("(0)1...(Don't) continue parameters optimization based on existing parameter file. 0..create new parameter file, 1..append to existing parameter file."); edc->TreeAdd("SolverOptions.Optimization",ed);
  ed.SetText(GetSolSet().paropt_method, "method"); ed.SetToolTipText("Genetic: optimize using random parameters, best parameters are further tracked."); edc->TreeAdd("SolverOptions.Optimization",ed);
  ed.SetInt(GetSolSet().par_opt_N_population, "initial_population_size"); ed.SetToolTipText("Size of initial trial values; also used for random Newton initialization."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetInt(GetSolSet().par_opt_N_survivors, "surviving_population_size"); ed.SetToolTipText("Size of values which are further tracked; also used for random Newton initialization."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetInt(GetSolSet().par_opt_N_children, "number_of_children"); ed.SetToolTipText("Number of children of surviving population."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetInt(GetSolSet().par_opt_N_generations, "number_of_generations"); ed.SetToolTipText("Number of generations in genetic optimization."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetDouble(GetSolSet().par_opt_range_reduction_factor, "range_reduction_factor"); ed.SetToolTipText("Reduction of range of possible mutations."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetDouble(GetSolSet().par_opt_randomizer_initialization, "randomizer_initialization"); ed.SetToolTipText("Initialization of random function."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetDouble(GetSolSet().par_opt_min_distance_factor, "min_allowed_distance_factor"); ed.SetToolTipText("Set to value greater than zero (distance is allowed radius of (hyper-)sphere in the normed parameter space (min=0)). Only the best parameter in the inner of the (hyper-)sphere is furtile."); edc->TreeAdd("SolverOptions.Optimization.Genetic",ed);
  ed.SetInt(GetSolSet().par_opt_N_pars, "number_of_params"); ed.SetToolTipText("Number of parameters to optimize."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetText(GetSolSet().par_opt_name1, "param_name1"); ed.SetToolTipText("Parameter name."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetDouble(GetSolSet().par_opt_minval1, "param_minval1"); ed.SetToolTipText("Lower limit of parameter."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetDouble(GetSolSet().par_opt_maxval1, "param_maxval1"); ed.SetToolTipText("Upper limit of parameter."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetText(GetSolSet().par_opt_name2, "param_name2"); ed.SetToolTipText("Parameter name."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetDouble(GetSolSet().par_opt_minval2, "param_minval2"); ed.SetToolTipText("Lower limit of parameter."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetDouble(GetSolSet().par_opt_maxval2, "param_maxval2"); ed.SetToolTipText("Upper limit of parameter."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetText(GetSolSet().par_opt_name3, "param_name3"); ed.SetToolTipText("Parameter name."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetDouble(GetSolSet().par_opt_minval3, "param_minval3"); ed.SetToolTipText("Lower limit of parameter."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetDouble(GetSolSet().par_opt_maxval3, "param_maxval3"); ed.SetToolTipText("Upper limit of parameter."); edc->TreeAdd("SolverOptions.Optimization.Parameters",ed);
  ed.SetInt(GetSolSet().par_sens_activate, "activate"); ed.SetToolTipText("(0)1...(Don't) analyze sensitivity of sensor values with respect to parameters."); edc->TreeAdd("SolverOptions.Sensitivity",ed);
  ed.SetText(GetSolSet().par_sens_method, "method"); ed.SetToolTipText("df/dx: Forward: use forward difference, Backward: use backward difference, Central: use central difference."); edc->TreeAdd("SolverOptions.Sensitivity",ed);
  ed.SetDouble(GetSolSet().par_sens_abs_diff_val, "num_diff_parameter_absolute"); ed.SetToolTipText("Absolute value D for computation of df/dx, dx=K*x+D."); edc->TreeAdd("SolverOptions.Sensitivity",ed);
  ed.SetDouble(GetSolSet().par_sens_rel_diff_val, "num_diff_parameter_relative"); ed.SetToolTipText("Relative factor K for computation of df/dx, dx=K*x+D."); edc->TreeAdd("SolverOptions.Sensitivity",ed);
  ed.SetBool(GetSolSet().par_sens_use_final_sensor_values, "use_final_sensor_values"); ed.SetToolTipText("(0)1...(Don't) use final sensor values."); edc->TreeAdd("SolverOptions.Sensitivity",ed);
  ed.SetBool(GetSolSet().par_sens_use_opt_params, "use_optimization_parameters"); ed.SetToolTipText("1|(0) ... (Don't) get parameters from Optimization.Parameters."); edc->TreeAdd("SolverOptions.Sensitivity",ed);
  ed.SetInt(GetSolSet().par_sens_N_pars, "number_of_params"); ed.SetToolTipText("Number of parameters."); edc->TreeAdd("SolverOptions.Sensitivity.Parameters",ed);
  ed.SetText(GetSolSet().par_sens_name1, "param_name1"); ed.SetToolTipText("Parameter name."); edc->TreeAdd("SolverOptions.Sensitivity.Parameters",ed);
  ed.SetText(GetSolSet().par_sens_name2, "param_name2"); ed.SetToolTipText("Parameter name."); edc->TreeAdd("SolverOptions.Sensitivity.Parameters",ed);
  ed.SetText(GetSolSet().par_sens_name3, "param_name3"); ed.SetToolTipText("Parameter name."); edc->TreeAdd("SolverOptions.Sensitivity.Parameters",ed);
  ed.SetBool(GetSolSet().parallel_activate, "use_parallel_threads"); ed.SetToolTipText("Use parallelization where possible (only some functionality is supported)."); edc->TreeAdd("SolverOptions.Misc.CPU",ed);
  ed.SetInt(GetSolSet().parallel_number_of_threads, "number_of_parallel_threads"); ed.SetToolTipText("Number of parallel threads to be used in parallelization."); edc->TreeAdd("SolverOptions.Misc.CPU",ed);
  ed.SetDouble(GetSolSet().withgraphics, "with_graphics"); ed.SetToolTipText("Will be erased! Redraw frequency: 0..off, 1..draw last frame, 2..100sec, 3..20sec, 4..2sec, 5..200ms, 6..50ms, 7..20ms, 8..every 10 frames, 9..every frame."); edc->TreeAdd("SolverOptions.Misc",ed);
  ed.SetBool(GetSolSet().usestoredsolversettings, "use_stored_solver_settings"); ed.SetToolTipText("1==use solversettings from cfg file, 0== use solversettings from here."); edc->TreeAdd("SolverOptions.Misc",ed);
  ed.SetText(GetSolSet().default_model_data_file, "default_model_data_file"); ed.SetToolTipText("Name and path of modeldata file to be loaded on initialization."); edc->TreeAdd("SolverOptions.Misc",ed);
}
void MultiBodySystem::EDC2SolverOptions(const ElementDataContainer* edc)
{
  GetSolSet().starttime = edc->TreeGetDouble("SolverOptions.start_time");
  GetSolSet().endtime = edc->TreeGetDouble("SolverOptions.end_time");
  GetSolSet().dostaticcomputation = edc->TreeGetInt("SolverOptions.do_static_computation");
  GetSolSet().maxstepsize = edc->TreeGetDouble("SolverOptions.Timeint.max_step_size");
  GetSolSet().minstepsize = edc->TreeGetDouble("SolverOptions.Timeint.min_step_size");
  GetSolSet().maxindex = edc->TreeGetInt("SolverOptions.Timeint.max_index");
  GetSolSet().tableauname = edc->TreeGetString("SolverOptions.Timeint.tableau_name");
  GetSolSet().maxstages = edc->TreeGetInt("SolverOptions.Timeint.max_stages");
  GetSolSet().minstages = edc->TreeGetInt("SolverOptions.Timeint.min_stages");
  GetSolSet().fulladaptive = edc->TreeGetInt("SolverOptions.Timeint.automatic_stepsize_control");
  GetSolSet().initstepsize = edc->TreeGetDouble("SolverOptions.Timeint.init_step_size");
  GetSolSet().absaccuracy = edc->TreeGetDouble("SolverOptions.Timeint.absolute_accuracy");
  GetSolSet().relaccuracy = edc->TreeGetDouble("SolverOptions.Timeint.relative_accuracy");
  GetSolSet().variable_order = edc->TreeGetInt("SolverOptions.Timeint.variable_order");
  GetSolSet().doimplicitintegration = edc->TreeGetInt("SolverOptions.Timeint.do_implicit_integration");
  GetSolSet().reset_after_simulation = edc->TreeGetInt("SolverOptions.Timeint.reset_after_simulation");
  GetSolSet().assume_constant_mass_matrix = edc->TreeGetInt("SolverOptions.Timeint.assume_constant_mass_matrix");
  GetSolSet().static_minloadinc = edc->TreeGetDouble("SolverOptions.Static.min_load_inc");
  GetSolSet().static_maxloadinc = edc->TreeGetDouble("SolverOptions.Static.max_load_inc");
  GetSolSet().static_initloadinc = edc->TreeGetDouble("SolverOptions.Static.init_load_inc");
  GetSolSet().static_loadinc_up = edc->TreeGetDouble("SolverOptions.Static.load_inc_up");
  GetSolSet().static_loadinc_down = edc->TreeGetDouble("SolverOptions.Static.load_inc_down");
  GetSolSet().static_incloadinc = edc->TreeGetInt("SolverOptions.Static.increase_load_inc_steps");
  GetSolSet().static_spring_type_reg_param = edc->TreeGetDouble("SolverOptions.Static.spring_regularisation_parameter");
  GetSolSet().static_use_tol_relax_factor = edc->TreeGetInt("SolverOptions.Static.use_tolerance_relax_factor");
  GetSolSet().static_maxtol_relax_factor = edc->TreeGetDouble("SolverOptions.Static.max_tolerance_relax_factor");
  GetSolSet().static_experimental_sparse_jacobian = edc->TreeGetInt("SolverOptions.Static.experimental_sparse_jacobian");
  GetSolSet().nls_relativeaccuracy = edc->TreeGetDouble("SolverOptions.Newton.relative_accuracy");
  GetSolSet().nls_absoluteaccuracy = edc->TreeGetDouble("SolverOptions.Newton.absolute_accuracy");
  GetSolSet().nls_numdiffepsi = edc->TreeGetDouble("SolverOptions.Newton.num_diff_parameter");
  GetSolSet().nls_symmetricjacobian = edc->TreeGetInt("SolverOptions.Newton.use_central_diff_quotient");
  GetSolSet().nls_modifiednewton = edc->TreeGetInt("SolverOptions.Newton.use_modified_newton");
  GetSolSet().nls_maxmodnewtonsteps = edc->TreeGetInt("SolverOptions.Newton.max_modified_newton_steps");
  GetSolSet().nls_maxrestartnewtonsteps = edc->TreeGetInt("SolverOptions.Newton.max_restart_newton_steps");
  GetSolSet().nls_maxfullnewtonsteps = edc->TreeGetInt("SolverOptions.Newton.max_full_newton_steps");
  GetSolSet().nls_trustregion = edc->TreeGetInt("SolverOptions.Newton.use_trust_region");
  GetSolSet().nls_trustregiondiv = edc->TreeGetDouble("SolverOptions.Newton.trust_region_division");
  GetSolSet().do_eigenmode_comp = edc->TreeGetInt("SolverOptions.Eigensolver.do_eigenmode_computation");
  GetSolSet().eigsolv_reuse_last_eigvec = edc->TreeGetInt("SolverOptions.Eigensolver.reuse_last_eigenvectors");
  GetSolSet().eigsolv_n_eigvals = edc->TreeGetInt("SolverOptions.Eigensolver.n_eigvals");
  GetSolSet().eigsolv_maxiterations = edc->TreeGetInt("SolverOptions.Eigensolver.max_iterations");
  GetSolSet().eigsolv_solvertype = edc->TreeGetInt("SolverOptions.Eigensolver.solver_type");
  GetSolSet().eigsolv_nzeromodes = edc->TreeGetInt("SolverOptions.Eigensolver.n_zero_modes");
  GetSolSet().eigsolv_use_nzeromodes = edc->TreeGetInt("SolverOptions.Eigensolver.use_n_zero_modes");
  GetSolSet().eigsolv_use_preconditioning = edc->TreeGetInt("SolverOptions.Eigensolver.use_preconditioning");
  GetSolSet().eigsolv_accuracy = edc->TreeGetDouble("SolverOptions.Eigensolver.accuracy");
  GetSolSet().eigsolv_precond_lambda = edc->TreeGetDouble("SolverOptions.Eigensolver.preconditioner_lambda");
  GetSolSet().eigsolv_eigenmodes_scaling_factor = edc->TreeGetDouble("SolverOptions.Eigensolver.eigenmodes_scaling_factor");
  GetSolSet().eigsolv_normalization_mode = edc->TreeGetInt("SolverOptions.Eigensolver.eigenmodes_normalization_mode");
  GetSolSet().eigsolv_linearize_about_act_sol = edc->TreeGetInt("SolverOptions.Eigensolver.linearize_about_actual_solution");
  GetSolSet().eigsolv_gyro = edc->TreeGetInt("SolverOptions.Eigensolver.use_gyroscopic_terms");
  GetSolSet().eigval_outp_format_flag = edc->TreeGetInt("SolverOptions.Eigensolver.eigval_outp_format_flag");
  GetSolSet().nls_usesparsesolver = edc->TreeGetInt("SolverOptions.Linalg.use_sparse_solver");
  GetSolSet().nls_solve_undetermined_system = edc->TreeGetInt("SolverOptions.Linalg.undetermined_system");
  GetSolSet().nls_estimated_condition_number = edc->TreeGetDouble("SolverOptions.Linalg.estimated_condition_number");
  GetSolSet().discontinuousaccuracy = edc->TreeGetDouble("SolverOptions.Discontinuous.absolute_accuracy");
  GetSolSet().maxdiscontinuousit = edc->TreeGetInt("SolverOptions.Discontinuous.max_iterations");
  GetSolSet().ignore_maxdiscontinuousit = edc->TreeGetInt("SolverOptions.Discontinuous.ignore_max_iterations");
  GetSolSet().writeresults = edc->TreeGetInt("SolverOptions.Solution.write_solution");
  GetSolSet().writesolstep = edc->TreeGetInt("SolverOptions.Solution.write_solution_every_x_step");
  GetSolSet().storedata = edc->TreeGetDouble("SolverOptions.Solution.store_data_every");
  GetSolSet().sol_data_to_files = edc->TreeGetInt("SolverOptions.Solution.store_data_to_files");
  GetSolSet().sol_immediately_write = edc->TreeGetInt("SolverOptions.Solution.immediately_write_file");
  GetSolSet().sol_replace_files = edc->TreeGetInt("SolverOptions.Solution.always_replace_files");
  GetSolSet().sol_write_sol_file_header = edc->TreeGetInt("SolverOptions.Solution.SolutionFile.write_solution_file_header");
  GetSolSet().sol_file_header_comment = edc->TreeGetString("SolverOptions.Solution.SolutionFile.solution_file_header_comment");
  GetSolSet().sol_directory = edc->TreeGetString("GeneralOptions.Paths.sensor_output_path");
  GetSolSet().sol_filename = edc->TreeGetString("SolverOptions.Solution.SolutionFile.output_filename");
  GetSolSet().sol_parfilename = edc->TreeGetString("SolverOptions.Solution.ParameterFile.parameter_variation_filename");
  GetSolSet().sol_parfile_write_final_sensor_values = edc->TreeGetInt("SolverOptions.Solution.ParameterFile.write_final_sensor_values");
  GetSolSet().sol_parfile_write_cost_function = edc->TreeGetInt("SolverOptions.Solution.ParameterFile.write_cost_function");
  GetSolSet().sol_parfile_write_second_order_size = edc->TreeGetInt("SolverOptions.Solution.ParameterFile.write_second_order_size");
  GetSolSet().sol_parfile_write_CPU_time = edc->TreeGetInt("SolverOptions.Solution.ParameterFile.write_CPU_time");
  GetSolSet().storesolution_state = edc->TreeGetInt("SolverOptions.Solution.store_solution_state");
  GetSolSet().storesolution_statename = edc->TreeGetString("SolverOptions.Solution.store_solution_state_name");
  GetSolSet().loadsolution_state = edc->TreeGetInt("SolverOptions.Solution.load_solution_state");
  GetSolSet().loadsolution_statename = edc->TreeGetString("SolverOptions.Solution.load_solution_state_name");
  GetSolSet().postproc_compute_eigenvalues = edc->TreeGetInt("SolverOptions.Solution.Sensor.postproc_compute_eigenvalues");
  GetSolSet().store_FE_matrices = edc->TreeGetInt("SolverOptions.Element.store_finite_elements_matrices");
  GetSolSet().element_wise_jacobian = edc->TreeGetInt("SolverOptions.Element.element_wise_jacobian");
  GetSolSet().parvar_activate = edc->TreeGetInt("SolverOptions.ParameterVariation.activate");
  GetSolSet().parvar_geometric = edc->TreeGetInt("SolverOptions.ParameterVariation.geometric");
  GetSolSet().parvar_start_value = edc->TreeGetDouble("SolverOptions.ParameterVariation.start_value");
  GetSolSet().parvar_end_value = edc->TreeGetDouble("SolverOptions.ParameterVariation.end_value");
  GetSolSet().parvar_step_lin = edc->TreeGetDouble("SolverOptions.ParameterVariation.arithmetic_step");
  GetSolSet().parvar_step_geom = edc->TreeGetDouble("SolverOptions.ParameterVariation.geometric_step");
  GetSolSet().parvar_EDCvarname = edc->TreeGetString("SolverOptions.ParameterVariation.MBS_EDC_variable_name");
  GetSolSet().parvar2_activate = edc->TreeGetInt("SolverOptions.ParameterVariation.Var2.activate");
  GetSolSet().parvar2_geometric = edc->TreeGetInt("SolverOptions.ParameterVariation.Var2.geometric");
  GetSolSet().parvar2_start_value = edc->TreeGetDouble("SolverOptions.ParameterVariation.Var2.start_value");
  GetSolSet().parvar2_end_value = edc->TreeGetDouble("SolverOptions.ParameterVariation.Var2.end_value");
  GetSolSet().parvar2_step_lin = edc->TreeGetDouble("SolverOptions.ParameterVariation.Var2.arithmetic_step");
  GetSolSet().parvar2_step_geom = edc->TreeGetDouble("SolverOptions.ParameterVariation.Var2.geometric_step");
  GetSolSet().parvar2_EDCvarname = edc->TreeGetString("SolverOptions.ParameterVariation.Var2.MBS_EDC_variable_name");
  GetSolSet().paropt_activate = edc->TreeGetInt("SolverOptions.Optimization.activate");
  GetSolSet().paropt_run_with_nominal_parameters = edc->TreeGetInt("SolverOptions.Optimization.run_with_nominal_parameters");
  GetSolSet().paropt_sensors = edc->TreeGetInt("SolverOptions.Optimization.sensors");
  GetSolSet().paropt_restart = edc->TreeGetInt("SolverOptions.Optimization.restart");
  GetSolSet().paropt_method = edc->TreeGetString("SolverOptions.Optimization.method");
  GetSolSet().par_opt_N_population = edc->TreeGetInt("SolverOptions.Optimization.Genetic.initial_population_size");
  GetSolSet().par_opt_N_survivors = edc->TreeGetInt("SolverOptions.Optimization.Genetic.surviving_population_size");
  GetSolSet().par_opt_N_children = edc->TreeGetInt("SolverOptions.Optimization.Genetic.number_of_children");
  GetSolSet().par_opt_N_generations = edc->TreeGetInt("SolverOptions.Optimization.Genetic.number_of_generations");
  GetSolSet().par_opt_range_reduction_factor = edc->TreeGetDouble("SolverOptions.Optimization.Genetic.range_reduction_factor");
  GetSolSet().par_opt_randomizer_initialization = edc->TreeGetDouble("SolverOptions.Optimization.Genetic.randomizer_initialization");
  GetSolSet().par_opt_min_distance_factor = edc->TreeGetDouble("SolverOptions.Optimization.Genetic.min_allowed_distance_factor");
  GetSolSet().par_opt_N_pars = edc->TreeGetInt("SolverOptions.Optimization.Parameters.number_of_params");
  GetSolSet().par_opt_name1 = edc->TreeGetString("SolverOptions.Optimization.Parameters.param_name1");
  GetSolSet().par_opt_minval1 = edc->TreeGetDouble("SolverOptions.Optimization.Parameters.param_minval1");
  GetSolSet().par_opt_maxval1 = edc->TreeGetDouble("SolverOptions.Optimization.Parameters.param_maxval1");
  GetSolSet().par_opt_name2 = edc->TreeGetString("SolverOptions.Optimization.Parameters.param_name2");
  GetSolSet().par_opt_minval2 = edc->TreeGetDouble("SolverOptions.Optimization.Parameters.param_minval2");
  GetSolSet().par_opt_maxval2 = edc->TreeGetDouble("SolverOptions.Optimization.Parameters.param_maxval2");
  GetSolSet().par_opt_name3 = edc->TreeGetString("SolverOptions.Optimization.Parameters.param_name3");
  GetSolSet().par_opt_minval3 = edc->TreeGetDouble("SolverOptions.Optimization.Parameters.param_minval3");
  GetSolSet().par_opt_maxval3 = edc->TreeGetDouble("SolverOptions.Optimization.Parameters.param_maxval3");
  GetSolSet().par_sens_activate = edc->TreeGetInt("SolverOptions.Sensitivity.activate");
  GetSolSet().par_sens_method = edc->TreeGetString("SolverOptions.Sensitivity.method");
  GetSolSet().par_sens_abs_diff_val = edc->TreeGetDouble("SolverOptions.Sensitivity.num_diff_parameter_absolute");
  GetSolSet().par_sens_rel_diff_val = edc->TreeGetDouble("SolverOptions.Sensitivity.num_diff_parameter_relative");
  GetSolSet().par_sens_use_final_sensor_values = edc->TreeGetInt("SolverOptions.Sensitivity.use_final_sensor_values");
  GetSolSet().par_sens_use_opt_params = edc->TreeGetInt("SolverOptions.Sensitivity.use_optimization_parameters");
  GetSolSet().par_sens_N_pars = edc->TreeGetInt("SolverOptions.Sensitivity.Parameters.number_of_params");
  GetSolSet().par_sens_name1 = edc->TreeGetString("SolverOptions.Sensitivity.Parameters.param_name1");
  GetSolSet().par_sens_name2 = edc->TreeGetString("SolverOptions.Sensitivity.Parameters.param_name2");
  GetSolSet().par_sens_name3 = edc->TreeGetString("SolverOptions.Sensitivity.Parameters.param_name3");
  GetSolSet().parallel_activate = edc->TreeGetInt("SolverOptions.Misc.CPU.use_parallel_threads");
  GetSolSet().parallel_number_of_threads = edc->TreeGetInt("SolverOptions.Misc.CPU.number_of_parallel_threads");
  GetSolSet().withgraphics = edc->TreeGetDouble("SolverOptions.Misc.with_graphics");
  GetSolSet().usestoredsolversettings = edc->TreeGetInt("SolverOptions.Misc.use_stored_solver_settings");
  GetSolSet().default_model_data_file = edc->TreeGetString("SolverOptions.Misc.default_model_data_file");
}
